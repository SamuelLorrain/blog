<h2>Introduction</h2>

<p>
Rogue est un jeu sortit en 1980. Il nous met dans la
peau d'un aventurier qui doit parcourir un donjon pour
y trouver un amulette.
</p>

<p>
C'est le fameux ancètre des rogueslikes. Vu sa date
de sortie, nous n'y trouvons pas de graphismes. Notre personnage
est représenté par le caractère <em>@</em> dans un terminal.
</p>

<!-- [image de rogue] -->

<p>
Dans Rogue, beaucoup d'éléments sont générés aléatoirement,
et c'est d'ailleurs de là que le jeu tire son intéret.
À chaque partie, la map est différente, et évidemment
les rencontres avec des ennemis aussi.
Plus original, l'aventurier qui arrive dans ce donjon
ne sait pas quel objet produit quel effet : Cette potion
rouge pourrait très bien le soigner ou le faire
dormir. Et à chaque partie, les noms des objets
sont modifiés aléatoirement. Une grande part du
jeu consiste donc à trouver comment identifier les
objets, un mécanisme qui prendra encore plus d'importance
dans <em>Nethack</em>, un clone amélioré de Rogue encore développé
aujourd'hui, et dans des variantes de ce dernier
(<em>SLASH'EM</em>, <em>Unethack</em> et j'en passe).
</p>

<p>
Qui dit aléatoire, dit générateur de nombre pseudo-aléatoire.
Le but de cet article est d'analyser ce générateur et comment
celui-ci est utilisé sur les objets.
</p>

<p>
Nous allons utiliser le code de Rogue présent sur le
dépot <a href="https://github.com/IIJ-NetBSD/netbsd-src">NetBSD de github</a>. Sur une version de Rogue
notée 5.3 ou "rogue-clone: Version III"
</p>

<h2>Un petit contretemps de compilation</h2>

<p>
Après avoir commencé l'analyse du code, je me suis rendu compte
qu'il n'était pas compilable en l'état. En effet, <em>NetBSD</em> défini
des macro non standard, et on se retrouve avec des <code>__dead</code>,
des <code>__printflike(x,y)</code> et autres <code>_RCSID(arg)</code>.
Ces macros sont définies dans <code>sys/cdefs.h</code> de <em>NetBSD</em>
et permettent certaines optimisations, ou de la gestion de version.
</p>

<p>Bref, pour que la compilation fonctionne, j'ai ajouté au début du fichier <code>rogue.h</code>:</p>

<pre><code>#define __dead
#define __printflike(fmtarg, firstvararg)
#define __unused
#define __unreachable()
#define strlcpy strncpy
#define strlcat strncat
#define fpurge __fpurge
</code></pre>

<p>pour remplacer les macros et fonctions non-standard.</p<>

<p>Aussi, voici un makefile fonctionnel sur linux:<p>

<pre><code>PROG=	rogue
SRCS=	hit.c init.c inventory.c level.c machdep.c main.c \
	message.c monster.c move.c object.c pack.c play.c random.c ring.c \
	room.c save.c score.c spec_hit.c throw.c trap.c use.c zap.c

${PROG} : ${SRCS}
	gcc ${SRCS} -o ${PROG} -Dlint -DUNIX -DUNIX_SYSV -lcurses
</code></pre>

<p>
Notons par ailleurs que Rogue ne semble pas fonctionner sur <em>Tilix</em> et d'autres terminaux
utilisant <em>VTE GTK3</em>, mais marche sur <em>urxvt</em>, <em>xterm</em> etc.
</p>

<h2>Utilisation de la randomisation dans l'initialisation des objets</h2>

<p>
C'est en lisant la fonction d'initialisation (<code>init()</code>)
qu'une curiosité m'a donné envie d'écrire cet article.
En effet, la randomisation du nom des objets se fait en 3 temps,
dans 3 fonctions différentes.
</p>

<p>
C'est curieux, car il y a 4 sortes d'objets randomisés
(potions,scrolls,wands,rings) qui fonctionnent de la même façon
dans le jeu.
</p>

<p>
On a dans la fonction <code>init()</code>:
</p>

<pre><code>/*...*/

mix_colors();                  //randomise les potions
get_wand_and_ring_materials(); //randomise les wands et rings
make_scrolls_title();          //randomise les scrolls

/*...*/
</code></pre>

<p>
Les types d'objets sont quant à eux stockés dans des
tableaux de <code>struct id</code>:
</p>
<pre><code>struct id {
	short value;                    //la valeur de l'objet (pour le vendre ou l'acheter)
	char title[MAX_ID_TITLE_LEN];   //le titre, valeur randomisée qui nous interesse ici
	const char *real;               //l'effet réel de l'objet :
                                        //("of healing","of teleportation")
	unsigned short id_status;       //l'objet est-il non identifié (0),
                                    //identifié (1), nommé par le joueur (2)
};
</code></pre>

<h2>Mix_Colors()</h2>

<pre><code>void mix_colors(void){
	short i, j, k;
	char t[MAX_ID_TITLE_LEN];

	for (i = 0; i <= 32; i++) {
		j = get_rand(0, (POTIONS - 1)); //get_rand(a,b) rend un nombre
                                            //aléatoire entre a et b inclus
		k = get_rand(0, (POTIONS - 1));
		strlcpy(t, id_potions[j].title, sizeof(t));
		strlcpy(id_potions[j].title, id_potions[k].title,
			sizeof(id_potions[j].title));
		strlcpy(id_potions[k].title, t, sizeof(id_potions[k].title));
	}
}
</code></pre>

<p>
La fonction est très simple, on tire au sort 2 éléments <em>title</em> du tableau
des potions, et on les permute 32 fois à l'aide d'un algorithme de swap.
Il y a donc des chances pour que certaines potions conservent leur titre
d'origine, car la fonction aura permuté plusieurs fois les mêmes élèments.
Mais aussi que le swap se fasse entre les deux mêmes élements et donc
n'avoir aucun effet.
On peut donc considérer que la fonction n'est pas très efficace.
</p>

<h2>Get_wand_and_ring_materials()</h2>

<pre><code>void
get_wand_and_ring_materials(void)
{
	short i, j;
	boolean used[WAND_MATERIALS];

	for (i = 0; i &lt; WAND_MATERIALS; i++) {
		used[i] = 0;
	}
	for (i = 0; i &lt; WANDS; i++) {
		do {
			j = get_rand(0, WAND_MATERIALS-1);
		} while (used[j]);
		used[j] = 1;
		(void)strlcpy(id_wands[i].title, wand_materials[j],
			       sizeof(id_wands[i].title));
		is_wood[i] = (j &gt; MAX_METAL);
	}
    /*...*/
}
</pre></code>

<p>
Ici, l'initialisation se fait en 2 temps.
Il n'y a d'ailleurs pas de raison de rassembler
l'initialisation des wands et des rings, d'après ce qu'on peut
voir ici.
</p>

<p>
La fonction utilise le tableau de boolean <code>used[]</code> pour éviter l'écueil
de la fonction <code>mix_color()</code>.
</p>

<p>
Tout se passe dans la boucle.
<code>used[]</code> est initialisée à 0 pour toutes ses cases.
Ensuite, on rentre dans la boucle for, et cherche
au hasard dans le tableau <code>used[]</code> une case à 0 (false).
On met cette case à 1 (true), et, en fonction de l'index <code>j</code> de la case,
on assigne un nom à la wand.
</p>
<p>
Grâce à cette technique, il n'est plus possible de de permuter plusieurs
fois la même wand, et tous les noms sont assignés aléatoirement.
Mais contrairement à la fonction <code>mix_color()</code>,
on doit appeler plusieurs fois <code>get_rand()</code> pour obtenir
une case vide du tableau <code>used[]</code>.
</p>

<p>
L'initalisation des rings se fait de la même façon dans la suite de la fonction.
</p>


<h2>Make_scrolls_title()</h2>

<pre><code>void make_scroll_titles(void) {
	short i, j, n;
	short sylls, s;
	size_t maxlen = sizeof(id_scrolls[0].title);

	for (i = 0; i &lt; SCROLS; i++) {
		sylls = get_rand(2, 5);
        /*...*/

		for (j = 0; j &lt; sylls; j++) {
			s = get_rand(1, (MAXSYLLABLES-1));
			(void)strlcat(id_scrolls[i].title,syllables[s],
					maxlen);
		}
        /*...*/
	}
}</code></pre>

<p>
Cette fonction est encore différentes, car au lieu de piocher
dans des noms pré-existants, la fonction utilise un dictionnaire de
syllables pour générer aléatoirement le nom des scrolls.
</p>
<p>
Chaque parchemin peut faire de 2 à 5 syllabes, et, comme il n'y a
aucun système de protection, plusieurs parchemins peuvent avoir
le même nom.
</p>


<h2>Analyse des fonctions aléatoires</h2>

<p>
Le générateur d'aléatoires est très similaire
aux fonctions <code>srandom_unlocked()</code> et
<code>random_unlocked()</code> présentes dans la <em>libc</em> de <em>Netbsd</em>.
</p>

<p>
Il est composé de deux fonctions <code>srrandom(int)</code> et
<code>rrandom()</code>, et des variables suivantes:
</p>
<pre><code>static long rntb[32] = {
	         3, 0x9a319039, 0x32d9c024, 0x9b663182, 0x5da1f342,
	0xde3b81e0, 0xdf0a6fb5, 0xf103bc02, 0x48f340fb, 0x7449e56b,
	0xbeb1dbb0, 0xab5c5918, 0x946554fd, 0x8c2e680f, 0xeb3d799f,
	0xb11ee0b7, 0x2d436b86, 0xda672e2a, 0x1588ca88, 0xe369735d,
	0x904f35f7, 0xd7158fd6, 0x6fa6f051, 0x616e6b96, 0xac94efdc,
	0x36413f93, 0xc622c298, 0xf5a42ab8, 0x8a88d77b, 0xf5ad9d0e,
	0x8999220b, 0x27fb47b9
};

static long *fptr = &amp;rntb[4];
static long *rptr = &amp;rntb[1];
static long *state = &amp;rntb[1];
static int rand_type = 3;
static int rand_deg = 31;
static int rand_sep = 3;
static long *end_ptr = &amp;rntb[32];
</code></pre>

<p>
Une première choses qui interpelle ici, c'est <code>rntb[0]</code> qui est égal à 3.
En fait, certaines implémentation de cette fonction (glibc, libc etc.)
utilisent cette première case du tableau à la place d'une variable <code>rand_type</code>.
Et nous verrons par la suite que la première case du tableau n'est jamais utilisée
dans l'algorithme.
</p>

<p>
Ce même <code>rand_type</code> est égal à 3. Cela fait référence à un type particulier d'aléatoire.
Il y en a 2 disponibles dans le code source : 0 ou 3 (!= 0).
</p>

<p>
Le type 0 est
un <a href="https://fr.wikipedia.org/wiki/G%C3%A9n%C3%A9rateur_congruentiel_lin%C3%A9aire">générateur congruentiel linéaire</a>
ou <em>GCL</em> est une fonction qui n'implique pas les variables que l'on a déjà vu, mais un calcul assez simple:
<code>nombre_aléatoire = state[0] = (state[0]*1103515245 + 12345) &amp; 0x7fffffff</code>,
qui utilise la variable <code>state</code> pour rendre un résultat différent à chaque appel.
Le <code>&amp; 0x7fffffff</code> est égal à la valeur maximale que peut prendre un nombre 32-bits signé, la
fonction ne peut donc pas rendre de nombre négatif.
</p>

<p>
Par défaut, c'est le type 3 qui est utilisé. On peut imaginer que sur une machine avec peu de
mémoire, on puisse utiliser le type 0 et gagner la place d'un tableau de 32 int, et l'execution
de quelques instructions.
</p>

<p>
Comme tout générateur pseudo aléatoire, celui de Rogue utilise une fonction de seed et une fonction
pour obtenir un nouveau nombre.
</p>

<p>
Voyons d'abord la fonction seed <code>srrandom(int)</code>, nettoyé des instructions de type 0 :
</p>

<pre><code>void srrandom(int x) {
	int i;
	state[0] = x;

    for (i = 1; i < rand_deg; i++) {
        state[i] = 1103515245 * state[i - 1] + 12345;
    }
    fptr = &amp;state[rand_sep];
    rptr = &amp;state[0];
    for (i = 0; i &lt; 10 * rand_deg; i++) {
        (void)rrandom();
    }
}
</code></pre>

<p>
Le seed, représenté par <code>x</code> est assignée à <code>state[0]</code>, qui correspond
à la 2eme case du tableau.
On retrouve dans le premier <code>for</code> notre fameux <em>GCL</em>:
Il sert ici à "saler" le seed en fonction de la variable <code>rand_deg</code>.
</p>

<p>
Ensuite, les valeurs des deux pointeurs <code>fptr</code> pour "front pointer"
et <code>rptr</code> pour "rear pointer", sont mis à des adresses particulières
du tableau, On va voir que le tableau va servir de machine à état pour le générateur,
et que ce sont ces variables qui vont s'occuper de modifier l'état.
</p>

<p>
Enfin, une deuxième boucle <code>for</code> va appeler la fonction rrandom <code>10*rand_deg</code> fois.
Ce qui, comme dans l'autres boucle, est une façon de rendre un peu plus difficile
les prévisions sur l'état du générateur.
</p>

<pre><code>static long rrandom(void) {
	long i;

    *fptr += *rptr;
    i = (*fptr &gt;&gt; 1) &amp; 0x7fffffff;
    fptr++;
    if (fptr &gt;= end_ptr) {
        fptr = state;
        rptr++;
    } else {
        rptr++;
        if (rptr &gt;= end_ptr) {
            rptr = state;
        }
    }
	return(i);
}</code></pre>

<p>
Cette fonction est le coeur du générateur.
<code>fptr</code> et <code>rptr</code> pointent sur deux cases du tableau. On va modifier
la valeur à <code>fptr</code> en ajoutant celle à <code>rptr</code>. On stocke cette valeur dans une
variable i (modulo 32 bits signés) qu'on renvoi à la fin de la fonction,
et on déplace les deux pointeurs vers la case suivante du tableau
par rapport à leurs positions respectives, ou au début du tableau si on est à la fin.
</p>

<p>
Comme le tableau <code>rnbt[32]</code> est initialisé avec des valeurs par défaut déjà
assez hasardeuses, on obtient des nombres difficilement prédictibles, et, comme la
valeur du tableau à <code>fptr</code> est modifiée à chaque appel de la fonction
(à la ligne <code>*fptr += *rptr;</code>), on obtient un générateur assez performant.
</p>


<h2>Utilisation dans le code</h2>

<p>
La fonction <code>rrandom()</code> n'est pas utilisée directement, elle passe par
une fonction <code>get_rand(int x, int y)</code> qui a deux fonctionnalité : tout
d'abord circonscrire le résultat entre <code>x</code> et <code>y</code>,
mais aussi restreindre le résultat dans 16 bits grâce à <code>lr &amp;= 0x3fff</code>
</p>

<p>
On note la présente d'une fonction <code>coin_toss()</code> qui renvoi aléatoirement
0 ou 1 et est utilisée à diverses reprises, que ce soit la génération de dongeon,
ou le déclenchement de certains évènement à  l'utilisation d'objets.
</p>

<p>
La seed est quant à elle initialisée dans la fonction <code>init()</code> de rogue,
en allant chercher, de façon assez habituelle, le <em>timestamp</em> gràce à un appel
standard.
</p>

